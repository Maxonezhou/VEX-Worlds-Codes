#pragma config(Sensor, in1,    ClawArmPotL,    sensorPotentiometer)
#pragma config(Sensor, in2,    ClawArmPotR,    sensorPotentiometer)
#pragma config(Sensor, in3,    ArmPotL,        sensorPotentiometer)
#pragma config(Sensor, in4,    ArmPotR,        sensorPotentiometer)
#pragma config(Sensor, in5,    MogoPot,        sensorPotentiometer)
#pragma config(Sensor, in6,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  EncLeft,        sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  EncRoll,        sensorNone)
#pragma config(Sensor, dgtl9,  EncRight,       sensorQuadEncoder)
#pragma config(Motor,  port1,           Right2,        tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, dgtl9)
#pragma config(Motor,  port2,           Left1,         tmotorVex393_MC29, openLoop, driveLeft, encoderPort, None)
#pragma config(Motor,  port3,           Roller,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           ClawArmL,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           TL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           TR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           ClawArmR,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           Mogo,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           Right1,        tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, dgtl9)
#pragma config(Motor,  port10,          Left2,         tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, None)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//+310 rotations for a 90 degree turn

//int MoptimalL;
//int MoptimalR;
int CoptimalL;
int CoptimalR;
int AoptimalL;
int AoptimalR;

task PID_ArmsLift
{
	float akp = 0.53; //tune
	float aki = 0.01; //tune
	float akd = 1.55; //tune

	float acurrentL;
	float aerrorTL;
	float alastErrorL = 0;
	float aproportionL;
	float aintegralL;
	float aderivativeL;
	float acurrentR ;
	float aerrorTR;
	float alastErrorR = 0;
	float aproportionR;
	float aintegralR;
	float aderivativeR;

	while(true){

		float aerrorL = AoptimalL - SensorValue[ArmPotL];
		float aerrorR = AoptimalR - SensorValue[ArmPotR];

		if (abs(aerrorL) < 200 && aerrorL != 0)
		{
			aerrorTL = aerrorL;
		}

		else{
			aerrorTL = 0;
		}

		if (abs(aerrorR) < 200 && aerrorR != 0)
		{
			aerrorTR = aerrorR;
		}

		else{
			aerrorTR = 0;
		}

		if (abs(aerrorTL) > 50 / aki){
			aerrorTL = 50 / aki;
		}

		if (aerrorL == 0){
			aderivativeL = 0;
		}

		if (abs(aerrorTR) > 50 / aki){
			aerrorTR = 50 / aki;
		}

		if (aerrorR == 0){
			aderivativeR = 0;
		}

		aproportionL = aerrorL * akp;
		aproportionR = aerrorR * akp;
		aintegralL = aerrorTL  * aki;
		aintegralR = aerrorTR  * aki;
		aderivativeL = (aerrorL - alastErrorL) * akd;
		aderivativeR = (aerrorR - alastErrorR) * akd;

		alastErrorL = aerrorL;
		alastErrorR = aerrorR;

		acurrentL = aproportionL + aintegralL + aderivativeL;
		acurrentR = aproportionR + aintegralR + aderivativeR;

		motor[TL] = acurrentL;
		motor[TR] = acurrentR;

		wait1Msec(40);

	}
	return;

}

/*void PID_ClawLift(int CoptimalL, int CoptimalR)
{
    float ckp = 0.16; //tune
    float cki = 0.00000001; //tune
    float ckd = 0.00000008; //tune

    float ccurrentL ;
    float cerrorTl;
    float clastErrorL = 0;
    float cproportionL;
    float cintegralL;
    float cderivativeL;
    float ccurrentR ;
    float cerrorTr;
    float clastErrorR = 0;
    float cproportionR;
    float cintegralR;
    float cderivativeR;

    while(true){


        float cerrorL = CoptimalL - SensorValue[ClawArmPotL];
        float cerrorR = CoptimalR - SensorValue[ClawArmPotR];

        if (abs(cerrorL) < 200 && cerrorL != 0)
        {
            cerrorTl = cerrorL;
        }
        else{
            cerrorTl = 0;
        }

        if (abs(cerrorR) < 200 && cerrorR != 0)
        {
            cerrorTr = cerrorR;
        }
        else{
            cerrorTr = 0;
        }

        if (abs(cerrorTl) > 50 / cki){
            cerrorTl = 50 / cki;
        }

        if (cerrorL == 0){
            cderivativeL = 0;
        }

        if (abs(cerrorTr) > 50 / cki){
            cerrorTr = 50 / cki;
        }

        if (cerrorR == 0){
            cderivativeR = 0;
        }




        cproportionL = cerrorL * ckp;
        cproportionR = cerrorR * ckp;
        cintegralL = cerrorTl  * cki;
        cintegralR = cerrorTr  * cki;
        cderivativeL = (cerrorL - clastErrorL) * ckd;
        cderivativeR = (cerrorR - clastErrorR) * ckd;

        clastErrorL = cerrorL;
        clastErrorR = cerrorR;

        ccurrentL = cproportionL + cintegralL + cderivativeL;
        ccurrentR = cproportionR + cintegralR + cderivativeR;

        motor[ClawArmR] = -ccurrentR;
        motor[ClawArmL] = -ccurrentL;



        wait1Msec(40);

    }
    return;

}
*/

/*task PID_MG()
{
    float mkp = 0.3; //tune
    float mki = 0.001; //tune
    float mkd = 0.2; //tune

    float mcurrentL ;
    float merrorTl;
    float mproportionL;
    float mintegralL;
    float mderivativeL;
    float mcurrentR ;
    float merrorTr;
    float mlastErrorR = 0;
    float mproportionR;
    float mintegralR;
    float mderivativeR;

    while(true){

        float merrorR = (MoptimalR - SensorValue[MogoPot]);

        if (abs(merrorR) < 200 && merrorR !=0)
        {
            merrorTr = merrorR;
        }
        else{
            merrorTr = 0;
        }

        if (abs(merrorTl)> 50 / mki){
            merrorTl = 50 / mki;
        }

        if (abs(merrorTr)> 50 / mki){
            merrorTr = 50 / mki;
        }

        if (merrorR ==0){
            mderivativeR = 0;
        }

        mproportionR = merrorR * mkp;
        mintegralL = merrorTl  * mki;
        mintegralR = merrorTr  * mki;
        mderivativeR = (merrorR - mlastErrorR) * mkd;

        mlastErrorR = merrorR;

        mcurrentL = mproportionL + mintegralL + mderivativeL;
        mcurrentR = mproportionR + mintegralR + mderivativeR;

        motor[Mogo] = mcurrentR;



        wait1Msec(40);

    }
    return;
}
*/
task main()
{
int AlasterrorL;
int AlasterrorR;
//int ClasterrorL;
//int ClasterrorR;

//    MoptimalR = SensorValue [MogoPot];
    CoptimalL = SensorValue [ClawArmPotL];
    CoptimalR = SensorValue [ClawArmPotR];
    AoptimalL = SensorValue [ArmPotL];
    AoptimalR = SensorValue [ArmPotR];

     //startTask (PID_MG);
     //startTask (PID_ClawLift);
    startTask (PID_ArmsLift);

    while(true){

        if(vexRT[Btn7DXmtr2] == 1)
        {
            //while((vexRT[Btn7DXmtr2] == 1)) {
                motor[Roller] = 127;

                //wait1Msec (40);
            //}
        }
        else if(vexRT[Btn8DXmtr2] == 1)
        {
            //while(vexRT[Btn8DXmtr2] == 1) {
                motor[Roller] = -127;

                //wait1Msec (40);
            //}
        }

        else {
            motor[Roller] = 18;
        }



        if(vexRT[Btn5UXmtr2] == 1)
        {
motor[TL] = motor[TR] = 127;
SensorValue[ArmPotL] = AlasterrorL;
SensorValue[ArmPotR] = AlasterrorR;
wait1Msec(40);
        }

        else if (vexRT[Btn5DXmtr2] == 1) {
motor[TL] = motor[TR]= -127;
SensorValue[ArmPotL] = AlasterrorL;
SensorValue[ArmPotR] = AlasterrorR;
wait1Msec(40);
        }


        else{
startTask (PID_ArmsLift);
wait1Msec(40);
        }

/*        if ((vexRT[Btn5U] == 1) && (SensorValue[ArmPotL] < 2225)){
            motor[TR] = motor[TL] = vexRT[Btn5U];
        }
        else if (vexRT[Btn5D] == 0){
            motor[TR] = motor[TL] = vexRT[Btn5D];
        }
        else{
        motor [TR]= motor [TL] = 0;
        }
*/

        if ((vexRT [Btn6U] == 1)||(vexRT [Btn6UXmtr2] == 1)) {
           motor[ClawArmL] = motor[ClawArmR] = 120;
            //CoptimalL = 939;
            //CoptimalR = 800;
        }

        else if ((vexRT[Btn6D] == 1)||(vexRT[Btn6DXmtr2] == 1)){
                //CoptimalL = 2550;
                //CoptimalR = 2700;
            motor[ClawArmL] = motor[ClawArmR] = -120;
        }
        else {
            motor[ClawArmL] = motor[ClawArmR] = 0;
        }


        if ((vexRT [Btn5D] == 1)) {
motor[Mogo] = -120;
        }

        else if (vexRT [Btn5U] == 1) {
motor[Mogo] = 120;
        }
        else {
motor [Mogo] = 0;
        }


        //---------------------------------------------------------------------------------------------------------------
     float ch3_drive;
        float ch1_drive;
        float a = vexRT[Ch3] / 127.0;
        float b = vexRT[Ch1] / 127.0;
        ch3_drive = (0.463 * (pow(a,3))- (0.069 * pow(a,2)) + (0.614 * a) ) * 127;
        ch1_drive = (0.463 * (pow(b,3))- (0.069 * pow(b,2)) + (0.614 * b) ) * 127;


        motor[Left1]  = ((ch3_drive) + (ch1_drive));
        motor[Left2]  = ((ch3_drive) + (ch1_drive));
        motor[Right1] = ((ch3_drive) - (ch1_drive));
        motor[Right2] = ((ch3_drive) - (ch1_drive));

        wait1Msec(40);


        /*float TR_lift;
        float TL_lift;
        float TRlift = vexRT[Btn5U];
        float TLlift = vexRT[Btn5U];
        TR_lift = (0.463 * (pow(TRlift,3))- (0.069 * pow(TRlift,2)) + (0.614 * TRlift)) * 127;
        TL_lift= (0.463 * (pow(TLlift,3))- (0.069 * pow(TLlift,2)) + (0.614 * TLlift)) * 127;

        motor[TR] = ((TR_lift) + TRlift);
        motor[TL] = ((TL_lift) + TLlift);*/

wait1Msec(40);
        }
}
