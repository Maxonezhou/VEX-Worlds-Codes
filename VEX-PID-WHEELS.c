#pragma config(Sensor, in1,    FourBarPot,     sensorPotentiometer)
#pragma config(Sensor, in2,    MobGoalPot,     sensorPotentiometer)
#pragma config(Sensor, in3,    LeftArmPot,     sensorPotentiometer)
#pragma config(Sensor, in4,    RightArmPot,    sensorPotentiometer)
#pragma config(Sensor, dgtl1,  LeftWheelsEnd,  sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightWheelsEnd, sensorQuadEncoder)
#pragma config(Motor,  port1,           GoliathIntake, tmotorVex393_HBridge, PIDControl, encoderPort, dgtl3)
#pragma config(Motor,  port2,           LeftWheels,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           RightWheels,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           LeftArmLiftBottom, tmotorVex393_MC29, openLoop, encoderPort, None)
#pragma config(Motor,  port5,           RightArmLiftBottom, tmotorVex393_MC29, openLoop, encoderPort, None)
#pragma config(Motor,  port6,           LeftFourBar,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RightArmLiftTop, tmotorVex393_MC29, openLoop, reversed, encoderPort, None)
#pragma config(Motor,  port8,           RightFourBar,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           LeftArmLiftTop, tmotorVex393_MC29, openLoop, reversed, encoderPort, None)
#pragma config(Motor,  port10,          MobileGoalLift, tmotorVex393_HBridge, PIDControl, reversed, encoderPort, dgtl3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(Sensor, dgtl1,  myEncoder,        sensorQuadEncoder)
//#pragma config(Motor,  port10, myMotor,    tmotorNormal, openLoop)

// PID using optical shaft encoder
//
// Shaft encoder has 360 pulses per revolution
//

#define PID_SENSOR_INDEXLW    LeftWheelsEnd
#define PID_SENSOR_SCALELW    1
#define PID_SENSOR_INDEXRW    RightWheelsEnd
#define PID_SENSOR_SCALERW    1

#define PID_MOTOR_INDEXLW     LeftWheels
#define PID_MOTOR_SCALELW     -1
#define PID_MOTOR_INDEXRW     RightWheels
#define PID_MOTOR_SCALERW     -1

#define PID_DRIVE_MAXLW       127
#define PID_DRIVE_MINLW     (-127)
#define PID_DRIVE_MAXRW       127
#define PID_DRIVE_MINRW     (-127)

#define PID_INTEGRAL_LIMITLW  50
#define PID_INTEGRAL_LIMITRW  50



// These could be constants but leaving
// as variables allows them to be modified in the debugger "live"
float  pid_KpLW = 3.0;
float  pid_KiLW = 0.04;
float  pid_KdLW = 0.0;

float  pid_KpRW = 3.0;
float  pid_KiRW = 0.04;
float  pid_KdRW = 0.0;

static int   pidRunningLW = 1;
static float pidRequestedValueLW;
static int   pidRunningRW = 1;
static float pidRequestedValueRW;

task pidController()
{
    float  pidSensorCurrentValueLW;
    float  pidErrorLW;
    float  pidLastErrorLW;
    float  pidIntegralLW;
    float  pidDerivativeLW;
    float  pidDriveLW;

    float  pidSensorCurrentValueRW;
    float  pidErrorRW;
    float  pidLastErrorRW;
    float  pidIntegralRW;
    float  pidDerivativeRW;
    float  pidDriveRW;

    //float  pidLastErrorWhTotal;
    //float  pidIntegralWhTotal;
    //float  pidDerivativeWhTotal;
    //float  pidDriveWhTotal;

    if(SensorType[ PID_SENSOR_INDEXLW ] == sensorQuadEncoder && SensorType[ PID_SENSOR_INDEXRW ] == sensorQuadEncoder){
        SensorValue[ PID_SENSOR_INDEXLW ] = 0;
        SensorValue[ PID_SENSOR_INDEXRW ] = 0;
		}
    pidLastErrorLW  = 0;
    pidIntegralLW   = 0;

    pidLastErrorRW  = 0;
    pidIntegralRW   = 0;

    //pidLastErrorWhTotal = 0;
    //pidIntegralWhTotal = 0;

    while( true )
        {
        // Is PID control active ?
        if( pidRunningLW == 1 && pidRunningRW == 1 )
            {
            // Read the sensor value and scale
            pidSensorCurrentValueLW = SensorValue[ PID_SENSOR_INDEXLW ] * PID_SENSOR_SCALELW;
            pidSensorCurrentValueRW = SensorValue[ PID_SENSOR_INDEXRW ] * PID_SENSOR_SCALERW;

            // calculate error
            pidErrorLW = pidSensorCurrentValueLW - pidRequestedValueLW;
            pidErrorRW = pidSensorCurrentValueRW - pidRequestedValueRW;

            // integral - if Ki is not 0
            if( pid_KiLW != 0 && pid_KiRW != 0)
                {
                // If we are inside controlable window then integrate the error
                if( abs(pidErrorLW) < PID_INTEGRAL_LIMITLW || abs(pidErrorRW) < PID_INTEGRAL_LIMITRW){
                    pidIntegralLW = pidIntegralLW + pidErrorLW;
                  	pidIntegralRW = pidIntegralRW + pidErrorRW;
                  	//pidIntegralWhTotal = pidIntegralLW + pidIntegralRW;
                }
                else {
                    pidIntegralLW = 0;
                  	pidIntegralRW = 0;
                  	//pidIntegralWhTotal = 0;
                }
                }
         		else {
                pidIntegralLW = 0;
              	pidIntegralRW = 0;
              	//pidIntegralWhTotal = 0;
                }
            // calculate the derivative
            pidDerivativeLW = pidErrorLW - pidLastErrorLW;
            pidLastErrorLW  = pidErrorLW;

            pidDerivativeRW = pidErrorRW - pidLastErrorRW;
            pidLastErrorRW = pidErrorRW;

            //pidLastErrorWhTotal = pidLastErrorLW - pidLastErrorRW;
            // calculate drive
            pidDriveLW = (pid_KpLW * pidErrorLW) + (pid_KiLW * pidIntegralLW) + (pid_KdLW * pidDerivativeLW);
            pidDriveRW = (pid_KpRW * pidErrorRW) + (pid_KiRW * pidIntegralRW) + (pid_KdRW * pidDerivativeRW);

            //pidDriveWhTotal = pidDriveLW - pidDriveRW;
            // limit drive
            if( pidDriveLW > PID_DRIVE_MAXLW )
                pidDriveLW = PID_DRIVE_MAXLW;
            if( pidDriveLW < PID_DRIVE_MINLW )
                pidDriveLW = PID_DRIVE_MINLW;

            if( pidDriveRW > PID_DRIVE_MAXRW )
                pidDriveRW = PID_DRIVE_MAXRW;
            if( pidDriveRW < PID_DRIVE_MINRW )
                pidDriveRW = PID_DRIVE_MINRW;

            // send to motor
            motor[ PID_MOTOR_SCALELW ] = pidDriveLW * PID_MOTOR_SCALELW;
            motor[ PID_MOTOR_SCALERW ] = pidDriveRW * PID_MOTOR_SCALERW;
            }
        else
            {
            // clear all
            pidErrorLW      = 0;
            pidLastErrorLW  = 0;
            pidIntegralLW   = 0;
            pidDerivativeLW = 0;
            motor[ PID_MOTOR_INDEXLW ] = 0;
            }

            pidErrorRW      = 0;
            pidLastErrorRW  = 0;
            pidIntegralRW   = 0;
            pidDerivativeRW = 0;
            motor[ PID_MOTOR_INDEXRW ] = 0;
            }

            //pidLastErrorWhTotal =0 ;
            //pidIntegralWhTotal = 0;
            //pidDerivativeWhTotal = 0;

        // Run at 50Hz
        wait1Msec( 25 );
        }

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  main task                                                                  */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

task main()
{
    // send the motor off somewhere
    pidRequestedValueLW = 1000;
    pidRequestedValueRW = 1000;

    // start the PID task
    startTask( pidController );

    // use joystick to modify the requested position
    while( true )
        {
        // maximum change for pidRequestedValue will be 127/4*20, around 640 counts per second
        // free spinning motor is 100rmp so 1.67 rotations per second
        // 1.67 * 360 counts is 600

        pidRequestedValueLW = pidRequestedValueLW + (vexRT[Ch3]/2);
        pidRequestedValueRW = pidRequestedValueRW + (vexRT[Ch2]/2);

        wait1Msec(50);
        }

}
